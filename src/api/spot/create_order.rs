use crate::http::{request::Request, Credentials, Method};

/// # Detailed descriptions
/// ##### text:
/// User defined information. If not empty, must follow the rules below:
///
/// prefixed with t-
/// no longer than 28 bytes without t- prefix
/// can only include 0-9, A-Z, a-z, underscore(_), hyphen(-) or dot(.)
/// Besides user defined information, reserved contents are listed below, denoting how the order is created:
/// - 101: from android
/// - 102: from IOS
/// - 103: from IPAD
/// - 104: from webapp
/// - 3: from web
/// - 2: from apiv2
/// - apiv4: from apiv4
///
/// ##### type:
/// Order Type
/// limit : Limit Order
/// market : Market Order
///
/// ##### amount:
/// When type is limit, it refers to base currency.
/// For instance, BTC_USDT means BTC When type is market, it refers to different currency according to side
///
/// side : buy means quote currency, BTC_USDT means USDT
/// side : sell means base currency，BTC_USDT means BTC
///
/// ##### time_in_force:
/// Time in force
/// - gtc: GoodTillCancelled
/// - ioc: ImmediateOrCancelled, taker only
/// - poc: PendingOrCancelled, makes a post-only order that always enjoys a maker fee
/// - fok: FillOrKill, fill either completely or none Only ioc and fok are supported when type=market
///
/// ##### auto_repay:
/// Enable or disable automatic repayment for automatic borrow loan generated by cross margin order.
/// Default is disabled.
///
/// Note that:
/// - This field is only effective for cross margin orders. Margin account does not support setting auto repayment for orders.
/// - auto_borrow and auto_repay can be both set to true in one order.
///
/// ##### stp_act:
/// Self-Trading Prevention Action. Users can use this field to set self-trade prevention strategies
///
/// - After users join the STP Group, he can pass stp_act to limit the user's self-trade prevetion strategy.
/// If stp_act is not passed, the default is cn strategy.
/// - When the user does not join the STP group, an error will be returned when passing the stp_act parameter.
/// - If the user did not use 'stp_act' when placing the order, 'stp_act' will return '-'
/// - cn: Cancel newest, Cancel new orders and keep old ones
/// - co: Cancel oldest, Cancel old orders and keep new ones
/// - cb: Cancel both, Both old and new orders will be cancelled
///
/// ## » action_mode:
/// Processing Mode: When placing an order, different fields are returned based on action_mode.
/// This field is only valid during the request and is not included in the response result
/// ACK: Asynchronous mode, only returns key order fields
/// RESULT: No clearing information
/// FULL: Full mode (default)
///
pub struct CreateOrder {
    pub text: Option<String>,
    pub currency_pair: String,
    pub order_type: Option<String>,
    pub account: Option<String>,
    pub side: String,
    pub amount: String,
    pub price: Option<String>,
    pub time_in_force: Option<String>,
    pub iceberg: Option<String>,
    pub auto_borrow: Option<bool>,
    pub auto_repay: Option<bool>,
    pub stp_act: Option<String>,
    pub action_mode: Option<String>,
    pub x_gate_exp_time: Option<u128>,
    pub credentials: Option<Credentials>,
}

impl CreateOrder {
    pub fn new(currency_pair: &str, side: &str, amount: &str) -> Self {
        Self {
            text: None,
            currency_pair: currency_pair.to_owned(),
            order_type: None,
            account: None,
            side: side.to_owned(),
            amount: amount.to_owned(),
            price: None,
            time_in_force: None,
            iceberg: None,
            auto_borrow: None,
            auto_repay: None,
            stp_act: None,
            action_mode: None,
            x_gate_exp_time: None,
            credentials: None,
        }
    }

    pub fn text(mut self, text: &str) -> Self {
        self.text = Some(text.into());
        self
    }

    pub fn order_type(mut self, order_type: &str) -> Self {
        self.order_type = Some(order_type.into());
        self
    }

    pub fn account(mut self, account: &str) -> Self {
        self.account = Some(account.into());
        self
    }

    pub fn price(mut self, price: &str) -> Self {
        self.price = Some(price.into());
        self
    }

    pub fn time_in_force(mut self, time_in_force: &str) -> Self {
        self.time_in_force = Some(time_in_force.into());
        self
    }

    pub fn iceberg(mut self, iceberg: &str) -> Self {
        self.iceberg = Some(iceberg.into());
        self
    }

    pub fn auto_borrow(mut self, auto_borrow: bool) -> Self {
        self.auto_borrow = Some(auto_borrow.into());
        self
    }

    pub fn auto_repay(mut self, auto_repay: bool) -> Self {
        self.auto_repay = Some(auto_repay.into());
        self
    }

    pub fn stp_act(mut self, stp_act: &str) -> Self {
        self.stp_act = Some(stp_act.into());
        self
    }

    pub fn action_mode(mut self, action_mode: &str) -> Self {
        self.action_mode = Some(action_mode.into());
        self
    }

    /// Specify the expiration time (milliseconds);<br/>
    /// If the GATE receives the request time greater than the expiration time, the request will be rejected
    pub fn x_gate_exp_time(mut self, x_gate_exp_time: u128) -> Self {
        self.x_gate_exp_time = Some(x_gate_exp_time.into());
        self
    }

    pub fn credentials(mut self, creds: Credentials) -> Self {
        self.credentials = Some(creds);
        self
    }
}

impl From<CreateOrder> for Request {
    fn from(request: CreateOrder) -> Request {
        let mut params = Vec::new();

        let mut payload = vec![
            ("currency_pair".to_owned(), request.currency_pair),
            ("side".to_owned(), request.side),
            ("amount".to_owned(), request.amount),
        ];

        if let Some(text) = request.text {
            payload.push(("text".into(), text.to_string()));
        }

        if let Some(order_type) = request.order_type {
            payload.push(("type".into(), order_type.to_string()));
        }

        if let Some(account) = request.account {
            payload.push(("account".into(), account.to_string()));
        }

        if let Some(price) = request.price {
            payload.push(("price".into(), price.to_string()));
        }

        if let Some(time_in_force) = request.time_in_force {
            payload.push(("time_in_force".into(), time_in_force.to_string()));
        }

        if let Some(iceberg) = request.iceberg {
            payload.push(("iceberg".into(), iceberg.to_string()));
        }

        if let Some(auto_borrow) = request.auto_borrow {
            payload.push(("auto_borrow".into(), auto_borrow.to_string()));
        }

        if let Some(auto_repay) = request.auto_repay {
            payload.push(("auto_repay".into(), auto_repay.to_string()));
        }

        if let Some(stp_act) = request.stp_act {
            payload.push(("stp_act".into(), stp_act.to_string()));
        }

        if let Some(action_mode) = request.action_mode {
            payload.push(("action_mode".into(), action_mode.to_string()));
        }

        Request {
            method: Method::Post,
            path: "/api/v4/spot/orders".into(),
            params,
            payload,
            x_gate_exp_time: request.x_gate_exp_time,
            credentials: request.credentials,
            sign: true,
        }
    }
}